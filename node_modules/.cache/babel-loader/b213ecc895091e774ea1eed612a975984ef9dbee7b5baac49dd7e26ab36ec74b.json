{"ast":null,"code":"import React from'react';import s from'./SuperInputText.module.css';// тип пропсов обычного инпута\n// здесь мы говорим что у нашего инпута будут такие же пропсы как у обычного инпута, кроме type\n// (чтоб не писать value: string, onChange: ...; они уже все описаны в DefaultInputPropsType)\nimport{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const SuperInputText=_ref=>{let{onChange,onChangeText,onKeyPress,onEnter,error,className,spanClassName,id,...restProps// все остальные пропсы попадут в объект restProps\n}=_ref;const onChangeCallback=e=>{onChange===null||onChange===void 0?void 0:onChange(e);// если есть пропс onChange, то передать ему е (поскольку onChange не обязателен)\nonChangeText===null||onChangeText===void 0?void 0:onChangeText(e.currentTarget.value);};const onKeyPressCallback=e=>{onKeyPress===null||onKeyPress===void 0?void 0:onKeyPress(e);onEnter&&// если есть пропс onEnter\ne.key==='Enter'&&// и если нажата кнопка Enter\nonEnter();// то вызвать его\n};const finalSpanClassName=s.error+(spanClassName?' '+spanClassName:'');const finalInputClassName=s.input+(error?' '+s.errorInput:' '+s.superInput)+(className?' '+className:'');// задача на смешивание классов\nreturn/*#__PURE__*/_jsxs(\"div\",{className:s.inputWrapper,children:[/*#__PURE__*/_jsx(\"input\",{id:id,type:'text',onChange:onChangeCallback,onKeyDown:onKeyPressCallback,className:finalInputClassName,...restProps}),/*#__PURE__*/_jsx(\"span\",{id:id?id+'-span':undefined,className:finalSpanClassName,children:error})]});};export default SuperInputText;","map":{"version":3,"names":["React","s","jsx","_jsx","jsxs","_jsxs","SuperInputText","_ref","onChange","onChangeText","onKeyPress","onEnter","error","className","spanClassName","id","restProps","onChangeCallback","e","currentTarget","value","onKeyPressCallback","key","finalSpanClassName","finalInputClassName","input","errorInput","superInput","inputWrapper","children","type","onKeyDown","undefined"],"sources":["/Users/vld/WebTools/css_projects/src/pages/Junior/s2/hw04/common/c1-SuperInputText/SuperInputText.tsx"],"sourcesContent":["import React, {\n    ChangeEvent,\n    DetailedHTMLProps,\n    InputHTMLAttributes,\n    KeyboardEvent,\n    ReactNode,\n} from 'react'\nimport s from './SuperInputText.module.css'\n\n// тип пропсов обычного инпута\ntype DefaultInputPropsType = DetailedHTMLProps<InputHTMLAttributes<HTMLInputElement>,\n    HTMLInputElement>\n\n// здесь мы говорим что у нашего инпута будут такие же пропсы как у обычного инпута, кроме type\n// (чтоб не писать value: string, onChange: ...; они уже все описаны в DefaultInputPropsType)\ntype SuperInputTextPropsType = Omit<DefaultInputPropsType, 'type'> & {\n    // и + ещё пропсы которых нет в стандартном инпуте\n    onChangeText?: (value: string) => void\n    onEnter?: () => void\n    error?: ReactNode\n    spanClassName?: string\n}\n\nconst SuperInputText: React.FC<SuperInputTextPropsType> = (\n    {\n        onChange,\n        onChangeText,\n        onKeyPress,\n        onEnter,\n        error,\n        className,\n        spanClassName,\n        id,\n\n        ...restProps // все остальные пропсы попадут в объект restProps\n    }\n) => {\n    const onChangeCallback = (e: ChangeEvent<HTMLInputElement>) => {\n        onChange?.(e) // если есть пропс onChange, то передать ему е (поскольку onChange не обязателен)\n        onChangeText?.(e.currentTarget.value)\n    }\n    const onKeyPressCallback = (e: KeyboardEvent<HTMLInputElement>) => {\n        onKeyPress?.(e)\n        onEnter && // если есть пропс onEnter\n        e.key === 'Enter' && // и если нажата кнопка Enter\n        onEnter() // то вызвать его\n    }\n\n    const finalSpanClassName = s.error\n        + (spanClassName ? ' ' + spanClassName : '')\n    const finalInputClassName = s.input\n        + (error ? ' ' + s.errorInput : ' ' + s.superInput)\n        + (className ? ' ' + className : '') // задача на смешивание классов\n\n    return (\n        <div className={s.inputWrapper}>\n            <input\n                id={id}\n                type={'text'}\n                onChange={onChangeCallback}\n                onKeyDown={onKeyPressCallback}\n                className={finalInputClassName}\n                {...restProps} // отдаём инпуту остальные пропсы если они есть (value например там внутри)\n            />\n            <span\n                id={id ? id + '-span' : undefined}\n                className={finalSpanClassName}\n            >\n                {error}\n            </span>\n        </div>\n    )\n}\n\nexport default SuperInputText\n"],"mappings":"AAAA,MAAO,CAAAA,KAAK,KAML,OAAO,CACd,MAAO,CAAAC,CAAC,KAAM,6BAA6B,CAE3C;AAIA;AACA;AAAA,OAAAC,GAAA,IAAAC,IAAA,CAAAC,IAAA,IAAAC,KAAA,yBASA,KAAM,CAAAC,cAAiD,CAAGC,IAAA,EAarD,IAZD,CACIC,QAAQ,CACRC,YAAY,CACZC,UAAU,CACVC,OAAO,CACPC,KAAK,CACLC,SAAS,CACTC,aAAa,CACbC,EAAE,CAEF,GAAGC,SAAU;AACjB,CAAC,CAAAT,IAAA,CAED,KAAM,CAAAU,gBAAgB,CAAIC,CAAgC,EAAK,CAC3DV,QAAQ,SAARA,QAAQ,iBAARA,QAAQ,CAAGU,CAAC,CAAC,CAAC;AACdT,YAAY,SAAZA,YAAY,iBAAZA,YAAY,CAAGS,CAAC,CAACC,aAAa,CAACC,KAAK,CAAC,CACzC,CAAC,CACD,KAAM,CAAAC,kBAAkB,CAAIH,CAAkC,EAAK,CAC/DR,UAAU,SAAVA,UAAU,iBAAVA,UAAU,CAAGQ,CAAC,CAAC,CACfP,OAAO,EAAI;AACXO,CAAC,CAACI,GAAG,GAAK,OAAO,EAAI;AACrBX,OAAO,CAAC,CAAC,CAAC;AACd,CAAC,CAED,KAAM,CAAAY,kBAAkB,CAAGtB,CAAC,CAACW,KAAK,EAC3BE,aAAa,CAAG,GAAG,CAAGA,aAAa,CAAG,EAAE,CAAC,CAChD,KAAM,CAAAU,mBAAmB,CAAGvB,CAAC,CAACwB,KAAK,EAC5Bb,KAAK,CAAG,GAAG,CAAGX,CAAC,CAACyB,UAAU,CAAG,GAAG,CAAGzB,CAAC,CAAC0B,UAAU,CAAC,EAChDd,SAAS,CAAG,GAAG,CAAGA,SAAS,CAAG,EAAE,CAAC,CAAC;AAEzC,mBACIR,KAAA,QAAKQ,SAAS,CAAEZ,CAAC,CAAC2B,YAAa,CAAAC,QAAA,eAC3B1B,IAAA,UACIY,EAAE,CAAEA,EAAG,CACPe,IAAI,CAAE,MAAO,CACbtB,QAAQ,CAAES,gBAAiB,CAC3Bc,SAAS,CAAEV,kBAAmB,CAC9BR,SAAS,CAAEW,mBAAoB,IAC3BR,SAAS,CAChB,CAAC,cACFb,IAAA,SACIY,EAAE,CAAEA,EAAE,CAAGA,EAAE,CAAG,OAAO,CAAGiB,SAAU,CAClCnB,SAAS,CAAEU,kBAAmB,CAAAM,QAAA,CAE7BjB,KAAK,CACJ,CAAC,EACN,CAAC,CAEd,CAAC,CAED,cAAe,CAAAN,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}